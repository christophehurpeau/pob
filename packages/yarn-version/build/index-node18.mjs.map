{"version":3,"file":"index-node18.mjs","sources":["../src/utils/UsageError.ts","../src/utils/execCommand.ts","../src/utils/packageUtils.ts","../src/commands/version.ts","../src/index.ts"],"sourcesContent":["export class UsageError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"UsageError\";\n  }\n}\n","import childProcess from \"node:child_process\";\nimport type { Workspace } from \"./packageUtils\";\n\ninterface ExecResultIfFailed {\n  code: number | null;\n  signal: string | null;\n  stdout: string;\n  stderr: string;\n}\n\ninterface ExecResultIfSuccess {\n  code: null;\n  signal: null;\n  stdout: string;\n  stderr: string;\n}\n\ntype ExecResult<Strict extends boolean> = Strict extends true\n  ? ExecResultIfSuccess\n  : ExecResultIfFailed;\n\nasync function execvp<const Strict extends boolean>(\n  command: string,\n  args: string[],\n  {\n    cwd = process.cwd(),\n    env = process.env,\n    encoding,\n    strict,\n    stdo = \"pipe\",\n  }: {\n    cwd?: string;\n    env?: typeof process.env;\n    encoding?: BufferEncoding;\n    strict?: Strict;\n    stdo?: \"inherit\" | \"pipe\";\n  },\n): Promise<ExecResult<Strict>> {\n  const stdoutChunks: Uint8Array[] = [];\n  const stderrChunks: Uint8Array[] = [];\n  if (env.PWD !== undefined) {\n    env = { ...env, PWD: cwd };\n  }\n  const subprocess = childProcess.spawn(command, args, {\n    cwd,\n    env,\n    stdio: [\"ignore\", stdo, stdo],\n  });\n  subprocess.stdout?.on(\"data\", (chunk) => {\n    stdoutChunks.push(chunk);\n  });\n  subprocess.stderr?.on(\"data\", (chunk) => {\n    stderrChunks.push(chunk);\n  });\n  return new Promise((resolve, reject) => {\n    subprocess.on(\"error\", (err) => {\n      reject(new Error(`Process ${command} failed to spawn`));\n    });\n    subprocess.on(\"close\", (code, signal) => {\n      const chunksToString = (chunks: Uint8Array[]): string =>\n        stdo === \"inherit\"\n          ? \"\"\n          : Buffer.concat(chunks).toString(encoding ?? \"utf8\");\n      const stdout = chunksToString(stdoutChunks);\n      const stderr = chunksToString(stderrChunks);\n      if (code === 0 || !strict) {\n        resolve({\n          code,\n          signal,\n          stdout,\n          stderr,\n        } as ExecResult<Strict>);\n      } else {\n        reject(\n          new Error(\n            `Process ${[command, ...args].join(\" \")} exited ${code !== null ? `with code ${code}` : `with signal ${signal || \"\"}`}:\\nstdout: ${stdout.toString()}\\nstderr: ${stderr.toString()}`,\n          ),\n        );\n      }\n    });\n  });\n}\n\nexport const execCommand = (\n  workspace: Workspace,\n  commandAndArgs: string[] = [],\n  stdo: \"inherit\" | \"pipe\" = \"pipe\",\n): ReturnType<typeof execvp> => {\n  const [command, ...args] = commandAndArgs;\n  return execvp(command, args, {\n    cwd: workspace.cwd,\n    strict: true,\n    stdo,\n  });\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport mapWorkspaces from \"@npmcli/map-workspaces\";\nimport prettyPkg from \"@pob/pretty-pkg\";\nimport type { PackageJson } from \"type-fest\";\n\nexport interface Workspace {\n  readonly cwd: string;\n  readonly relativeCwd?: string;\n  readonly pkg: PackageJson;\n}\n\nexport interface ProjectWorkspace {\n  readonly root: Workspace;\n  readonly children: Map<string, Workspace>;\n}\n\nexport const createProjectWorkspace = async (\n  root: Workspace,\n): Promise<ProjectWorkspace> => {\n  const map: Map<string, string> = root.pkg.workspaces\n    ? await mapWorkspaces({ cwd: root.cwd, pkg: root.pkg })\n    : new Map();\n\n  const children = new Map<string, Workspace>(\n    await Promise.all(\n      [...map.entries()].map(\n        async ([packageName, packagePath]) =>\n          [\n            packageName,\n            {\n              ...(await createWorkspace(packagePath)),\n              relativeCwd: path.relative(root.cwd, packagePath),\n            } satisfies Workspace,\n          ] as const,\n      ),\n    ),\n  );\n  return { root, children };\n};\n\nconst isAccessible = (path: string): Promise<boolean> =>\n  fs.access(path).then(\n    () => true,\n    () => false,\n  );\n\nexport const findRootWorkspace = async (\n  cwd: string,\n): Promise<Workspace | null> => {\n  let currentPath = cwd;\n  do {\n    const isRootIfOneOfThesePathsExists = await Promise.all([\n      isAccessible(path.join(currentPath, \".yarnrc.yml\")),\n      isAccessible(path.join(currentPath, \"yarn.lock\")),\n    ]);\n    if (isRootIfOneOfThesePathsExists.some(Boolean)) {\n      return createWorkspace(currentPath);\n    }\n    currentPath = path.dirname(currentPath);\n  } while (currentPath && currentPath !== \"/\");\n  return null;\n};\n\nconst getPackageJsonPath = (cwd: string): string =>\n  path.join(cwd, \"package.json\");\n\nexport const createWorkspace = async (path: string): Promise<Workspace> => {\n  const pkg = await readPkg(path);\n  return { cwd: path, pkg };\n};\n\nexport async function writePkg(\n  workspace: Workspace,\n  prettierOptions = undefined,\n): Promise<void> {\n  const string = await prettyPkg(workspace.pkg, prettierOptions);\n  await fs.writeFile(getPackageJsonPath(workspace.cwd), string, \"utf8\");\n}\n\nexport async function readPkg(cwd: string): Promise<PackageJson> {\n  const packagePath = getPackageJsonPath(cwd);\n  // eslint-disable-next-line @typescript-eslint/use-unknown-in-catch-callback-variable\n  const pkg = await fs.readFile(packagePath, \"utf8\").catch((error: Error) => {\n    throw new Error(\n      `Failed to read package.json in \"${cwd}\": ${error instanceof Error ? error.message : String(error)}`,\n    );\n  });\n  try {\n    return JSON.parse(pkg);\n  } catch (error: unknown) {\n    throw new Error(\n      `Failed to parse package.json in \"${cwd}\": ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n","/* eslint-disable complexity */\nimport path from \"node:path\";\n// eslint-disable-next-line import/no-unresolved\nimport { ConventionalGitClient } from \"@conventional-changelog/git-client\";\nimport { Option, program } from \"commander\";\nimport { addConfig, Level, Logger } from \"nightingale\";\nimport { ConsoleHandler } from \"nightingale-console\";\nimport { satisfies } from \"semver\";\nimport { UsageError } from \"../utils/UsageError\";\nimport type { BumpType } from \"../utils/bumpTypeUtils\";\nimport {\n  calcBumpRange,\n  calcBumpType,\n  getHighestBumpType,\n  incrementVersion,\n} from \"../utils/bumpTypeUtils\";\nimport {\n  recommendBump,\n  generateChangelog,\n} from \"../utils/conventionalChangelogUtils\";\nimport { loadConventionalCommitConfig } from \"../utils/conventionalCommitConfigUtils\";\nimport { execCommand } from \"../utils/execCommand\";\nimport { asyncIterableToArray } from \"../utils/generatorUtils\";\nimport {\n  createGitCommit,\n  createGitTag,\n  getDirtyFiles,\n  getGitCurrentBranch,\n  isBehindRemote,\n  pushCommitsAndTags,\n} from \"../utils/gitUtils\";\nimport {\n  createGitHubClient,\n  createGitRelease,\n  parseGithubRepoUrl,\n} from \"../utils/githubUtils\";\nimport {\n  PackageDependencyDescriptorUtils,\n  PackageDescriptorNameUtils,\n  type PackageDependencyDescriptor,\n} from \"../utils/packageDependenciesUtils\";\nimport type { Workspace } from \"../utils/packageUtils\";\nimport {\n  createProjectWorkspace,\n  createWorkspace,\n  findRootWorkspace,\n  writePkg,\n} from \"../utils/packageUtils\";\nimport { updateChangelogFile } from \"../utils/updateChangelog\";\nimport type { DependencyType } from \"../utils/workspaceUtils\";\nimport {\n  buildDependenciesMaps,\n  buildTopologicalOrderBatches,\n  getWorkspaceName,\n} from \"../utils/workspaceUtils\";\n\nexport interface VersionCommandOptions {\n  cwd: string;\n  includesRoot: boolean;\n  dryRun: boolean;\n  force?: \"major\" | \"minor\" | \"patch\";\n  prerelease?: string;\n  json: boolean;\n  preset: string;\n  tagVersionPrefix: string;\n  changelog: string;\n  commitMessage: string;\n  createRelease: boolean;\n  bumpDependentsHighestAs: \"major\" | \"minor\" | \"patch\";\n  alwaysBumpPeerDependencies: boolean;\n  gitRemote: string;\n  ignoreChanges?: string;\n  verbose?: boolean;\n  cwdIsRoot?: boolean;\n}\n\ninterface BumpableWorkspace {\n  workspace: Workspace;\n  previousTag?: string;\n  workspaceName: string;\n  isRoot: boolean;\n  version: string;\n}\n\ninterface ChangedWorkspace {\n  bumpReason?: string;\n  bumpType: BumpType;\n}\n\ninterface NoVersionToUpdateWorkspace {\n  // for legacy configuration not using workspaces ranges https://yarnpkg.com/features/workspaces#workspace-ranges-workspace\n  dependenciesToBump: [DependencyType, PackageDependencyDescriptor, string][];\n}\n\ninterface BumpedWorkspace extends ChangedWorkspace, NoVersionToUpdateWorkspace {\n  bumpForDependenciesReasons?: string[];\n  hasChanged: boolean;\n  currentVersion: string;\n  newVersion: string;\n  newTag: string | null;\n}\n\nexport const versionCommandAction = async (\n  options: VersionCommandOptions,\n  { nightingaleHandler = new ConsoleHandler(Level.INFO) } = {},\n): Promise<void> => {\n  // todo nightingale-cli\n  if (options.json) {\n    process.env.NIGHTINGALE_CONSOLE_FORMATTER = \"json\";\n  }\n\n  addConfig({\n    pattern: /^yarn-version/,\n    handler: nightingaleHandler,\n  });\n\n  const logger = new Logger(\"yarn-version\");\n\n  const rootWorkspace = await (options.cwdIsRoot\n    ? createWorkspace(options.cwd)\n    : findRootWorkspace(options.cwd));\n\n  if (!rootWorkspace) {\n    throw new UsageError(\"Could not find root workspace from this path.\");\n  }\n\n  await execCommand(rootWorkspace, [\"yarn\", \"install\"], \"inherit\");\n  return;\n\n  const project = await createProjectWorkspace(rootWorkspace);\n\n  if (!options.dryRun) {\n    const dirtyFiles = await getDirtyFiles(project.root);\n    if (dirtyFiles) {\n      throw new Error(\n        `Dirty Files:\\n${dirtyFiles}\\n\\nThere are uncommitted changes in the git repository. Please commit or stash them first.`,\n      );\n    }\n  }\n\n  const rootWorkspaceChildren = [...project.children.values()];\n  let rootNewVersion = \"\";\n  let rootNewTag = \"\";\n  const isMonorepo = rootWorkspaceChildren.length > 0;\n  const isMonorepoVersionIndependent = isMonorepo && !rootWorkspace.pkg.version;\n  const workspaces =\n    !isMonorepo || options.includesRoot\n      ? [rootWorkspace, ...rootWorkspaceChildren]\n      : rootWorkspaceChildren;\n\n  if (options.prerelease) {\n    throw new UsageError(\"--prerelease is not supported yet.\");\n  }\n  if (options.ignoreChanges) {\n    throw new UsageError(\"--ignore-changes is not supported yet.\");\n  }\n\n  const conventionalGitClient = new ConventionalGitClient(rootWorkspace.cwd);\n\n  const rootPreviousVersionTagPromise = options.force\n    ? null\n    : conventionalGitClient.getLastSemverTag({\n        prefix: options.tagVersionPrefix,\n        skipUnstable: true,\n      });\n\n  const [\n    conventionalCommitConfig,\n    githubClient,\n    parsedRepoUrl,\n    gitCurrentBranch,\n  ] = await Promise.all([\n    loadConventionalCommitConfig(rootWorkspace, options.preset),\n    // create client early to fail fast if necessary\n    options.createRelease ? createGitHubClient() : undefined,\n    options.createRelease ? parseGithubRepoUrl(rootWorkspace) : undefined,\n    getGitCurrentBranch(rootWorkspace),\n  ]);\n\n  const buildTagName = (workspace: Workspace, version: string): string =>\n    `${\n      isMonorepo && workspace !== rootWorkspace\n        ? `${getWorkspaceName(workspace)}@`\n        : options.tagVersionPrefix\n    }${version}`;\n\n  const changedWorkspaces = new Map<Workspace, ChangedWorkspace>();\n  const dependenciesMap = isMonorepo ? buildDependenciesMaps(project) : null;\n\n  // todo logger.group\n  logger.info(\n    options.force\n      ? \"Check all workspaces (force option)\"\n      : \"Finding changed workspaces\",\n  );\n\n  // check workspaces and create bumpableWorkspaces\n\n  const bumpableWorkspaces: BumpableWorkspace[] = [];\n  for (const workspace of workspaces) {\n    const workspaceName = getWorkspaceName(workspace);\n    const isRoot = workspace === rootWorkspace;\n    if (isRoot && isMonorepo) continue;\n\n    const version = workspace.pkg.version;\n\n    if (!version || version === \"0.0.0\") {\n      if (\n        (isRoot || isMonorepoVersionIndependent) &&\n        (!isMonorepo || !isMonorepoVersionIndependent)\n      ) {\n        throw new UsageError(\n          'package.json has no version in its manifest. For the first release, set to \"1.0.0-pre\" or \"0.1.0-pre\".',\n        );\n      }\n\n      logger.info(`${workspaceName}: skipped (no version)`);\n      continue;\n    }\n\n    bumpableWorkspaces.push({\n      workspace,\n      workspaceName,\n      isRoot,\n      version,\n    });\n  }\n\n  if (bumpableWorkspaces.length > 0) {\n    logger.info(\"Found bumpable workspaces\", {\n      count: bumpableWorkspaces.length,\n    });\n  }\n\n  const previousTagByWorkspace = new Map<Workspace, string | undefined>(\n    await Promise.all(\n      bumpableWorkspaces.map(async ({ workspace, workspaceName, isRoot }) => {\n        const packageOption =\n          isMonorepo && isMonorepoVersionIndependent\n            ? workspaceName\n            : undefined;\n\n        const previousVersionTagPrefix = packageOption\n          ? `${packageOption}@`\n          : options.tagVersionPrefix;\n\n        const previousTag = await (isRoot || !isMonorepoVersionIndependent\n          ? rootPreviousVersionTagPromise\n          : conventionalGitClient.getLastSemverTag({\n              prefix: previousVersionTagPrefix,\n              skipUnstable: true,\n            }));\n\n        return [workspace, previousTag || undefined] as const;\n      }),\n    ),\n  );\n\n  const commitsByWorkspace = options.force\n    ? undefined\n    : new Map(\n        await Promise.all(\n          bumpableWorkspaces.map(async ({ workspace }) => {\n            const previousTag = previousTagByWorkspace.get(workspace);\n\n            const workspaceRelativePath = path.relative(\n              rootWorkspace.cwd,\n              workspace.cwd,\n            );\n            return [\n              workspace,\n              await asyncIterableToArray(\n                conventionalGitClient.getCommits(\n                  { path: workspaceRelativePath, from: previousTag },\n                  conventionalCommitConfig.parser,\n                ),\n              ),\n            ] as const;\n          }),\n        ),\n      );\n\n  // find changed workspaces\n\n  for (const { workspace, workspaceName } of bumpableWorkspaces) {\n    let bumpType: BumpType | null = null;\n    let bumpReason: string | undefined;\n\n    if (options.force) {\n      bumpType = options.force;\n      bumpReason = \"forced by --force flag\";\n    } else {\n      const commits = commitsByWorkspace?.get(workspace);\n\n      // No changes found for this package\n      if (!commits || commits.length === 0) {\n        logger.info(`${workspaceName}: skipped (no changes)`);\n        continue;\n      }\n\n      const { releaseType, reason } = await recommendBump(\n        commits,\n        conventionalCommitConfig,\n      );\n      bumpReason = reason;\n\n      if (releaseType) {\n        bumpType = releaseType as BumpType;\n      }\n    }\n\n    if (bumpType) {\n      if (isMonorepo && !workspace.pkg.name) {\n        throw new Error(\"Workspace name is required\");\n      }\n\n      const currentVersion = workspace.pkg.version;\n\n      if (!currentVersion) {\n        throw new UsageError(\n          `Invalid \"${getWorkspaceName(workspace)}\" version`,\n        );\n      }\n\n      changedWorkspaces.set(workspace, {\n        bumpType,\n        bumpReason,\n      });\n    }\n  }\n\n  if (changedWorkspaces.size === 0) {\n    logger.info(\"No changed workspaces\");\n    return;\n  }\n\n  logger.info(\"Preparing bumping\");\n\n  const bumpedWorkspaces = new Map<Workspace, BumpedWorkspace>();\n  const noVersionToUpdateWorkspaces = new Map<\n    Workspace,\n    NoVersionToUpdateWorkspace\n  >();\n  const batches = dependenciesMap\n    ? buildTopologicalOrderBatches(project, dependenciesMap)\n    : [[rootWorkspace]];\n\n  for (const batch of batches) {\n    for (const workspace of batch) {\n      const currentVersion = workspace.pkg.version;\n\n      if (!currentVersion && !workspace.pkg.private) {\n        throw new UsageError(\n          `Invalid \"${getWorkspaceName(workspace)}\" version`,\n        );\n      }\n\n      const changedWorkspace = changedWorkspaces.get(workspace);\n      let bumpType: BumpType | null = null;\n      const bumpReasons: string[] = [];\n      const dependenciesToBump: BumpedWorkspace[\"dependenciesToBump\"] = [];\n\n      if (changedWorkspace) {\n        bumpType = changedWorkspace.bumpType;\n        bumpReasons.push(changedWorkspace.bumpReason || \"by commits\");\n      }\n\n      const dependencies = dependenciesMap?.get(workspace);\n\n      if (dependencies) {\n        for (const [\n          dependencyWorkspace,\n          dependencyType,\n          dependencyDescriptor,\n        ] of dependencies) {\n          const dependencyBumpedWorkspace =\n            bumpedWorkspaces.get(dependencyWorkspace);\n\n          if (!dependencyBumpedWorkspace) {\n            continue;\n          }\n\n          if (\n            dependencyType === \"peerDependencies\" &&\n            !options.alwaysBumpPeerDependencies &&\n            // skip when peerdependency with a new version satisfied by the existing range.\n            satisfies(\n              dependencyBumpedWorkspace.newVersion,\n              dependencyDescriptor.selector,\n              { includePrerelease: true },\n            )\n          ) {\n            continue;\n          }\n\n          const newRange = calcBumpRange(\n            workspace,\n            dependencyDescriptor.selector,\n            dependencyBumpedWorkspace.newVersion,\n          );\n\n          if (dependencyDescriptor.selector === newRange) {\n            continue;\n          }\n\n          dependenciesToBump.push([\n            dependencyType,\n            dependencyDescriptor,\n            newRange,\n          ]);\n\n          bumpType = getHighestBumpType([\n            bumpType ?? \"patch\",\n            calcBumpType(\n              dependencyBumpedWorkspace.bumpType,\n              options.bumpDependentsHighestAs,\n            ),\n          ]);\n\n          bumpReasons.push(\n            `Version bump for dependency: ${PackageDescriptorNameUtils.stringify(dependencyDescriptor.name)}`,\n          );\n        }\n      }\n\n      const workspaceName = getWorkspaceName(workspace);\n      if (!currentVersion) {\n        logger.info(`${workspaceName}: skipped (no version)`);\n        if (workspace !== rootWorkspace) {\n          noVersionToUpdateWorkspaces.set(workspace, {\n            dependenciesToBump,\n          });\n        }\n      } else if (!bumpType) {\n        logger.info(\n          `${workspaceName}: skipped (${\n            changedWorkspace\n              ? `no bump recommended by ${options.preset}`\n              : \"no changes\"\n          })`,\n        );\n      } else {\n        const newVersion = incrementVersion(\n          workspace,\n          currentVersion,\n          bumpType,\n        );\n\n        const tagName = buildTagName(workspace, newVersion);\n\n        if (workspace === rootWorkspace) {\n          rootNewVersion = newVersion;\n          rootNewTag = tagName;\n        }\n\n        if (workspace !== rootWorkspace || !isMonorepo) {\n          const bumpReason = bumpReasons.join(\"\\n\");\n          bumpedWorkspaces.set(workspace, {\n            currentVersion,\n            bumpType,\n            bumpReason,\n            bumpForDependenciesReasons: changedWorkspace\n              ? bumpReasons.slice(1)\n              : bumpReasons,\n            newVersion,\n            newTag: tagName,\n            hasChanged: changedWorkspace !== undefined,\n            dependenciesToBump,\n          });\n\n          logger.info(\n            `${workspaceName}: ${currentVersion} -> ${\n              !isMonorepo || isMonorepoVersionIndependent ? newVersion : \"bump\"\n            } (${bumpReason.replace(\"\\n\", \" ; \")})`,\n          );\n          // TODO Json only:\n          // logger.info({\n          //   cwd: npath.fromPortablePath(workspace.cwd),\n          //   ident: workspaceName,\n          //   oldVersion: currentVersion,\n          //   ...(isMonorepoVersionIndependent ? { newVersion } : {}),\n          //   bumpType,\n          //   bumpReasons,\n          // });\n        }\n      }\n    }\n  }\n\n  // TODO ask for confirmation\n  // if (!this.yes) {\n  // }\n\n  // TODO do this entire phase here, not override for not independent only\n  if (isMonorepo && !isMonorepoVersionIndependent) {\n    const currentVersion = rootWorkspace.pkg.version!;\n    const highestBumpType = getHighestBumpType(\n      [...bumpedWorkspaces.values()].map(({ bumpType }) => bumpType),\n    );\n    const newVersion = incrementVersion(\n      rootWorkspace,\n      currentVersion,\n      highestBumpType,\n    );\n    rootNewVersion = newVersion;\n    rootNewTag = buildTagName(rootWorkspace, newVersion);\n\n    [...bumpedWorkspaces.entries()].forEach(([workspace, bumpedWorkspace]) => {\n      const isRoot = workspace === rootWorkspace;\n      if (isRoot) {\n        throw new Error(\"Unexpected root found in bumped workspaces\");\n      }\n      bumpedWorkspace.bumpType = highestBumpType;\n      bumpedWorkspace.newVersion = newVersion;\n      bumpedWorkspace.newTag = null;\n    });\n\n    [\n      ...bumpedWorkspaces.entries(),\n      ...noVersionToUpdateWorkspaces.entries(),\n    ].forEach(([workspace, { dependenciesToBump }]) => {\n      dependenciesToBump.forEach((dependencyToBump) => {\n        dependencyToBump[2] = calcBumpRange(\n          workspace,\n          dependencyToBump[1].selector,\n          newVersion,\n        );\n      });\n    });\n\n    bumpedWorkspaces.set(rootWorkspace, {\n      currentVersion,\n      bumpType: highestBumpType,\n      hasChanged: true,\n      newVersion: rootNewVersion,\n      newTag: rootNewTag,\n      dependenciesToBump: [],\n    });\n\n    logger.info(\n      `${currentVersion} -> ${newVersion}`,\n      // TODO Json only:\n      // {\n      //   oldVersion: currentVersion,\n      //   newVersion, },\n    );\n  }\n\n  // do modifications\n\n  // Update yarn.lock ; must be done to make sure preversion script can be ran\n  logger.info(`${getWorkspaceName(rootWorkspace)}: Running install`);\n  await execCommand(rootWorkspace, [\"yarn\", \"install\"], \"inherit\");\n\n  logger.info(\"Lifecycle script: preversion\");\n\n  if (isMonorepoVersionIndependent && rootWorkspace.pkg.scripts?.preversion) {\n    await execCommand(rootWorkspace, [\"yarn\", \"run\", \"preversion\"], \"inherit\");\n  }\n\n  if (!options.dryRun) {\n    // lifecycle: preversion\n    for (const workspace of bumpedWorkspaces.keys()) {\n      if (workspace.pkg.scripts?.preversion) {\n        await execCommand(workspace, [\"yarn\", \"run\", \"preversion\"], \"inherit\");\n      }\n    }\n\n    logger.info(\"Modifying versions in package.json\");\n    // update versions\n\n    await Promise.all(\n      [...bumpedWorkspaces.entries()].map(\n        ([workspace, { newVersion, dependenciesToBump }]) => {\n          workspace.pkg.version = newVersion;\n\n          for (const [\n            dependencyType,\n            dependencyDescriptor,\n            dependencyNewRange,\n          ] of dependenciesToBump) {\n            const newDescriptor = PackageDependencyDescriptorUtils.make(\n              dependencyDescriptor,\n              dependencyNewRange,\n            );\n            const [key, newValue] =\n              PackageDependencyDescriptorUtils.stringify(newDescriptor);\n            workspace.pkg[dependencyType]![key] = newValue;\n          }\n\n          return writePkg(workspace);\n        },\n      ),\n    );\n\n    // Update yarn.lock ; must be done before running again lifecycle scripts\n    logger.info(`${getWorkspaceName(rootWorkspace)}: Running install`);\n    await execCommand(rootWorkspace, [\"yarn\", \"install\"], \"inherit\");\n\n    // lifecycle: version\n    logger.info(\"Lifecycle script: version\");\n    for (const workspace of bumpedWorkspaces.keys()) {\n      if (workspace.pkg.scripts?.version) {\n        spawnSync(\"yarn run version\", {\n          cwd: workspace.cwd,\n          stdio: \"inherit\",\n        });\n      }\n    }\n  }\n\n  if (isMonorepoVersionIndependent && rootWorkspace.pkg.scripts?.version) {\n    spawnSync(\"yarn run version\", {\n      cwd: rootWorkspace.cwd,\n      stdio: \"inherit\",\n    });\n  }\n\n  const changelogs = new Map<Workspace, string>();\n\n  await Promise.all(\n    [...bumpedWorkspaces.entries()].map(\n      async ([\n        workspace,\n        { newTag, hasChanged, bumpReason, bumpForDependenciesReasons },\n      ]) => {\n        const workspaceRelativePath =\n          rootWorkspace === workspace\n            ? undefined\n            : path.relative(rootWorkspace.cwd, workspace.cwd);\n\n        let changelog = await generateChangelog(\n          rootWorkspace,\n          workspace.pkg,\n          conventionalCommitConfig,\n          newTag,\n          {\n            path: workspaceRelativePath,\n            previousTag: previousTagByWorkspace.get(workspace),\n            verbose: options.verbose,\n            tagPrefix: options.tagVersionPrefix,\n            lernaPackage:\n              rootWorkspace === workspace || !isMonorepoVersionIndependent\n                ? undefined\n                : getWorkspaceName(workspace),\n          },\n        );\n\n        if (bumpForDependenciesReasons && workspace !== rootWorkspace) {\n          if (bumpForDependenciesReasons.length > 0) {\n            changelog += `${!changelog.endsWith(\"\\n\\n\") ? \"\\n\" : \"\"}${bumpForDependenciesReasons.join(\"\\n\")}\\n\\n`;\n          }\n        }\n\n        if (changelog.slice(changelog.indexOf(\"\\n\")).trim().length === 0) {\n          changelog += `${!changelog.endsWith(\"\\n\\n\") ? \"\\n\" : \"\"}Note: no notable changes\\n\\n`;\n        }\n\n        changelogs.set(workspace, changelog);\n\n        if (options.changelog) {\n          if (options.dryRun) {\n            logger.info(\n              `${getWorkspaceName(workspace)}: ${\n                options.changelog\n              }\\n${changelog}`,\n            );\n          } else {\n            await updateChangelogFile(\n              changelog,\n              options.tagVersionPrefix,\n              `${workspace.cwd}/${options.changelog}`,\n            );\n          }\n        }\n      },\n    ),\n  );\n\n  if (!options.dryRun) {\n    // TODO nightingale separator\n    console.log();\n\n    // install to update versions in lock file\n    logger.info(`${getWorkspaceName(rootWorkspace)}: Running install`);\n    spawnSync(\"yarn install\", {\n      cwd: options.cwd,\n      stdio: \"inherit\",\n    });\n\n    // TODO nightingale separator\n    console.log();\n\n    logger.info(\"Commit, tag and push\", {\n      changedFiles: await getDirtyFiles(rootWorkspace),\n    });\n\n    const tagsSet = new Set<string>(\n      [...bumpedWorkspaces.values()]\n        .map(({ newTag }) => newTag)\n        .filter((newTag) => newTag !== null) as string[],\n    );\n\n    const tagsInCommitMessage = [...tagsSet]\n      .map((tag) => `- ${tag}`)\n      .join(\"\\n\");\n    const message = options.commitMessage\n      .replace(/\\\\n/g, \"\\n\")\n      .replace(\n        /%a/g,\n        isMonorepoVersionIndependent\n          ? `\\n\\n${tagsInCommitMessage}`\n          : rootNewVersion,\n      )\n      .replace(/%s/g, rootNewTag)\n      .replace(/%v/g, rootNewVersion)\n      .replace(/%t/g, tagsInCommitMessage);\n\n    await createGitCommit(rootWorkspace, message);\n\n    for (const [workspace, { newTag }] of bumpedWorkspaces.entries()) {\n      if (newTag === null) continue;\n      await createGitTag(workspace, newTag);\n    }\n\n    if (\n      await isBehindRemote(rootWorkspace, options.gitRemote, gitCurrentBranch)\n    ) {\n      logger.error(\"Remote is ahead, aborting\");\n      // eslint-disable-next-line n/no-process-exit, unicorn/no-process-exit\n      process.exit(1);\n    }\n\n    await pushCommitsAndTags(\n      rootWorkspace,\n      options.gitRemote,\n      gitCurrentBranch,\n    );\n\n    // run postversion\n    if (rootWorkspace.pkg.scripts?.postversion) {\n      spawnSync(\"yarn run postversion\", {\n        cwd: rootWorkspace.cwd,\n        stdio: \"inherit\",\n      });\n    }\n\n    // TODO open github PR\n\n    if (options.createRelease && githubClient && parsedRepoUrl) {\n      logger.info(\"Create git release\");\n\n      await Promise.all(\n        [...bumpedWorkspaces.entries()].map(([workspace, { newTag }]) => {\n          if (newTag === null) return undefined;\n          const changelog = changelogs.get(workspace);\n          if (!changelog) {\n            logger.warn(\n              `No changelog found for workspace: ${getWorkspaceName(\n                workspace,\n              )}`,\n            );\n            return undefined;\n          }\n          return createGitRelease(\n            githubClient,\n            parsedRepoUrl,\n            newTag,\n            changelog,\n            !!options.prerelease,\n          );\n        }),\n      );\n    }\n  }\n\n  if (process.env.NODE_ENV !== \"test\") {\n    // issue in @conventional-changelog/git-client\n    // eslint-disable-next-line n/no-process-exit, unicorn/no-process-exit\n    process.exit(0);\n  }\n};\n\nexport const Defaults: VersionCommandOptions = {\n  cwd: process.cwd(),\n  includesRoot: false,\n  dryRun: false,\n  json: false,\n  preset: \"conventional-changelog-conventionalcommits\",\n  tagVersionPrefix: \"v\",\n  changelog: \"CHANGELOG.md\",\n  commitMessage: \"chore: release %a\",\n  createRelease: false,\n  bumpDependentsHighestAs: \"major\",\n  alwaysBumpPeerDependencies: false,\n  gitRemote: \"origin\",\n  verbose: false,\n};\n\nexport default program\n  .command(\"version\")\n  .usage(\"Bump package version using conventional commit\")\n  .addOption(\n    new Option(\"--includes-root\", \"Release root workspace [untested]\").default(\n      Defaults.includesRoot,\n    ),\n  )\n  .addOption(new Option(\"--cwd\", \"working directory\").default(process.cwd()))\n  .addOption(\n    new Option(\n      \"--dry-run\",\n      \"Print the versions without actually generating the package archive\",\n    ).default(Defaults.dryRun),\n  )\n  .addOption(new Option(\"-v,--verbose\").default(Defaults.verbose))\n  .addOption(\n    new Option(\"--force <type>\", \"Specify the release type\").choices([\n      \"major\",\n      \"minor\",\n      \"patch\",\n    ]),\n  )\n  .addOption(\n    new Option(\n      \"--prerelease [releaseType]\",\n      \"Add a prerelease identifier to new versions\",\n    ),\n  )\n  .addOption(\n    new Option(\n      \"--preset <presetName>\",\n      \"Conventional Changelog preset to require. Defaults to conventional-changelog-conventionalcommits.\",\n    ).default(\"conventional-changelog-conventionalcommits\"),\n  )\n  .addOption(\n    new Option(\"--tag-version-prefix <prefix>\", \"Tag version prefix\").default(\n      Defaults.tagVersionPrefix,\n    ),\n  )\n  .addOption(\n    new Option(\n      \"--changelog <path>\",\n      \"Changelog path. Default to CHANGELOG.md.\",\n    ).default(Defaults.changelog),\n  )\n  .addOption(\n    new Option(\n      \"-m,--commit-message <message>\",\n      'Commit message. Default to \"chore: release %a\". You can use %v for the version, %s for the version with prefix, %t to list tags, %a for auto best display.',\n    ).default(Defaults.commitMessage),\n  )\n  .addOption(\n    new Option(\"--create-release <type>\", \"Create a release\").choices([\n      \"github\",\n    ]),\n  )\n  .addOption(\n    new Option(\n      \"--bump-dependents-highest-as <type>\",\n      \"Bump dependents highest version as major, minor or patch\",\n    )\n      .choices([\"major\", \"minor\", \"patch\"])\n      .default(Defaults.bumpDependentsHighestAs),\n  )\n  .addOption(\n    new Option(\n      \"--always-bump-peer-dependencies\",\n      \"Always bump peer dependencies. Default to bumping only if the version doesn't satisfies the peer dependency range.\",\n    ).default(Defaults.alwaysBumpPeerDependencies),\n  )\n  .addOption(\n    new Option(\n      \"--git-remote <remote-name>\",\n      \"Git remote to push commits and tags to\",\n    ).default(Defaults.gitRemote),\n  )\n  .addOption(\n    new Option(\n      \"--ignore-changes <glob>\",\n      'Ignore changes in files matching the glob. Example: \"**/*.test.js\"',\n    ),\n  )\n  .action((options) => versionCommandAction(options));\n","import fs from \"node:fs\";\nimport { program } from \"commander\";\n\nimport \"./commands/version\";\n\n// relative to dist directory\nconst pkg = JSON.parse(\n  // eslint-disable-next-line unicorn/prefer-json-parse-buffer\n  fs.readFileSync(new URL(\"../package.json\", import.meta.url), \"utf8\"),\n);\n\nprogram.name(pkg.name).description(pkg.description).version(pkg.version);\nprogram.parse();\n"],"names":["path","fs"],"mappings":";;;;;;;;;;;;;;;;AAAO,MAAM,mBAAmB,KAAM,CAAA;AAAA,EACpC,YAAY,OAAiB,EAAA;AAC3B,IAAA,KAAA,CAAM,OAAO,CAAA,CAAA;AACb,IAAA,IAAA,CAAK,IAAO,GAAA,YAAA,CAAA;AAAA,GACd;AACF;;ACgBA,eAAe,MAAA,CACb,SACA,IACA,EAAA;AAAA,EACE,GAAA,GAAM,QAAQ,GAAI,EAAA;AAAA,EAClB,MAAM,OAAQ,CAAA,GAAA;AAAA,EACd,QAAA;AAAA,EACA,MAAA;AAAA,EACA,IAAO,GAAA,MAAA;AACT,CAO6B,EAAA;AAC7B,EAAA,MAAM,eAA6B,EAAC,CAAA;AACpC,EAAA,MAAM,eAA6B,EAAC,CAAA;AACpC,EAAI,IAAA,GAAA,CAAI,QAAQ,KAAW,CAAA,EAAA;AACzB,IAAA,GAAA,GAAM,EAAE,GAAG,GAAK,EAAA,GAAA,EAAK,GAAI,EAAA,CAAA;AAAA,GAC3B;AACA,EAAA,MAAM,UAAa,GAAA,YAAA,CAAa,KAAM,CAAA,OAAA,EAAS,IAAM,EAAA;AAAA,IACnD,GAAA;AAAA,IACA,GAAA;AAAA,IACA,KAAO,EAAA,CAAC,QAAU,EAAA,IAAA,EAAM,IAAI,CAAA;AAAA,GAC7B,CAAA,CAAA;AACD,EAAA,UAAA,CAAW,MAAQ,EAAA,EAAA,CAAG,MAAQ,EAAA,CAAC,KAAU,KAAA;AACvC,IAAA,YAAA,CAAa,KAAK,KAAK,CAAA,CAAA;AAAA,GACxB,CAAA,CAAA;AACD,EAAA,UAAA,CAAW,MAAQ,EAAA,EAAA,CAAG,MAAQ,EAAA,CAAC,KAAU,KAAA;AACvC,IAAA,YAAA,CAAa,KAAK,KAAK,CAAA,CAAA;AAAA,GACxB,CAAA,CAAA;AACD,EAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAW,KAAA;AACtC,IAAW,UAAA,CAAA,EAAA,CAAG,OAAS,EAAA,CAAC,GAAQ,KAAA;AAC9B,MAAA,MAAA,CAAO,IAAI,KAAA,CAAM,CAAW,QAAA,EAAA,OAAO,kBAAkB,CAAC,CAAA,CAAA;AAAA,KACvD,CAAA,CAAA;AACD,IAAA,UAAA,CAAW,EAAG,CAAA,OAAA,EAAS,CAAC,IAAA,EAAM,MAAW,KAAA;AACvC,MAAA,MAAM,cAAiB,GAAA,CAAC,MACtB,KAAA,IAAA,KAAS,SACL,GAAA,EAAA,GACA,MAAO,CAAA,MAAA,CAAO,MAAM,CAAA,CAAE,QAAS,CAAA,QAAA,IAAY,MAAM,CAAA,CAAA;AACvD,MAAM,MAAA,MAAA,GAAS,eAAe,YAAY,CAAA,CAAA;AAC1C,MAAM,MAAA,MAAA,GAAS,eAAe,YAAY,CAAA,CAAA;AAC1C,MAAI,IAAA,IAAA,KAAS,CAAK,IAAA,CAAC,MAAQ,EAAA;AACzB,QAAQ,OAAA,CAAA;AAAA,UACN,IAAA;AAAA,UACA,MAAA;AAAA,UACA,MAAA;AAAA,UACA,MAAA;AAAA,SACqB,CAAA,CAAA;AAAA,OAClB,MAAA;AACL,QAAA,MAAA;AAAA,UACE,IAAI,KAAA;AAAA,YACF,WAAW,CAAC,OAAA,EAAS,GAAG,IAAI,CAAA,CAAE,KAAK,GAAG,CAAC,CAAW,QAAA,EAAA,IAAA,KAAS,OAAO,CAAa,UAAA,EAAA,IAAI,KAAK,CAAe,YAAA,EAAA,MAAA,IAAU,EAAE,CAAE,CAAA,CAAA;AAAA,QAAc,EAAA,MAAA,CAAO,UAAU,CAAA;AAAA,QAAa,EAAA,MAAA,CAAO,UAAU,CAAA,CAAA;AAAA,WACpL;AAAA,SACF,CAAA;AAAA,OACF;AAAA,KACD,CAAA,CAAA;AAAA,GACF,CAAA,CAAA;AACH,CAAA;AAEO,MAAM,cAAc,CACzB,SAAA,EACA,iBAA2B,EAAC,EAC5B,OAA2B,MACG,KAAA;AAC9B,EAAA,MAAM,CAAC,OAAA,EAAS,GAAG,IAAI,CAAI,GAAA,cAAA,CAAA;AAC3B,EAAO,OAAA,MAAA,CAAO,SAAS,IAAM,EAAA;AAAA,IAC3B,KAAK,SAAU,CAAA,GAAA;AAAA,IACf,MAAQ,EAAA,IAAA;AAAA,IACR,IAAA;AAAA,GACD,CAAA,CAAA;AACH,CAAA;;ACpDA,MAAM,eAAe,CAACA,KAAAA,KACpB,EAAG,CAAA,MAAA,CAAOA,KAAI,CAAE,CAAA,IAAA;AAAA,EACd,MAAM,IAAA;AAAA,EACN,MAAM,KAAA;AACR,CAAA,CAAA;AAEW,MAAA,iBAAA,GAAoB,OAC/B,GAC8B,KAAA;AAC9B,EAAA,IAAI,WAAc,GAAA,GAAA,CAAA;AAClB,EAAG,GAAA;AACD,IAAM,MAAA,6BAAA,GAAgC,MAAM,OAAA,CAAQ,GAAI,CAAA;AAAA,MACtD,YAAa,CAAA,IAAA,CAAK,IAAK,CAAA,WAAA,EAAa,aAAa,CAAC,CAAA;AAAA,MAClD,YAAa,CAAA,IAAA,CAAK,IAAK,CAAA,WAAA,EAAa,WAAW,CAAC,CAAA;AAAA,KACjD,CAAA,CAAA;AACD,IAAI,IAAA,6BAAA,CAA8B,IAAK,CAAA,OAAO,CAAG,EAAA;AAC/C,MAAA,OAAO,gBAAgB,WAAW,CAAA,CAAA;AAAA,KACpC;AACA,IAAc,WAAA,GAAA,IAAA,CAAK,QAAQ,WAAW,CAAA,CAAA;AAAA,GACxC,QAAS,eAAe,WAAgB,KAAA,GAAA,EAAA;AACxC,EAAO,OAAA,IAAA,CAAA;AACT,CAAA,CAAA;AAEA,MAAM,qBAAqB,CAAC,GAAA,KAC1B,IAAK,CAAA,IAAA,CAAK,KAAK,cAAc,CAAA,CAAA;AAElB,MAAA,eAAA,GAAkB,OAAOA,KAAqC,KAAA;AACzE,EAAM,MAAA,GAAA,GAAM,MAAM,OAAA,CAAQA,KAAI,CAAA,CAAA;AAC9B,EAAO,OAAA,EAAE,GAAKA,EAAAA,KAAAA,EAAM,GAAI,EAAA,CAAA;AAC1B,CAAA,CAAA;AAUA,eAAsB,QAAQ,GAAmC,EAAA;AAC/D,EAAM,MAAA,WAAA,GAAc,mBAAmB,GAAG,CAAA,CAAA;AAE1C,EAAM,MAAA,GAAA,GAAM,MAAM,EAAG,CAAA,QAAA,CAAS,aAAa,MAAM,CAAA,CAAE,KAAM,CAAA,CAAC,KAAiB,KAAA;AACzE,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,gCAAA,EAAmC,GAAG,CAAM,GAAA,EAAA,KAAA,YAAiB,QAAQ,KAAM,CAAA,OAAA,GAAU,MAAO,CAAA,KAAK,CAAC,CAAA,CAAA;AAAA,KACpG,CAAA;AAAA,GACD,CAAA,CAAA;AACD,EAAI,IAAA;AACF,IAAO,OAAA,IAAA,CAAK,MAAM,GAAG,CAAA,CAAA;AAAA,WACd,KAAgB,EAAA;AACvB,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,iCAAA,EAAoC,GAAG,CAAM,GAAA,EAAA,KAAA,YAAiB,QAAQ,KAAM,CAAA,OAAA,GAAU,MAAO,CAAA,KAAK,CAAC,CAAA,CAAA;AAAA,KACrG,CAAA;AAAA,GACF;AACF;;ACMO,MAAM,oBAAuB,GAAA,OAClC,OACA,EAAA,EAAE,kBAAqB,GAAA,IAAI,cAAe,CAAA,KAAA,CAAM,IAAI,CAAA,EAAM,GAAA,EACxC,KAAA;AAElB,EAAA,IAAI,QAAQ,IAAM,EAAA;AAChB,IAAA,OAAA,CAAQ,IAAI,6BAAgC,GAAA,MAAA,CAAA;AAAA,GAC9C;AAEA,EAAU,SAAA,CAAA;AAAA,IACR,OAAS,EAAA,eAAA;AAAA,IACT,OAAS,EAAA,kBAAA;AAAA,GACV,CAAA,CAAA;AAED,EAAe,IAAI,MAAA,CAAO,cAAc,EAAA;AAExC,EAAM,MAAA,aAAA,GAAgB,OAAO,OAAA,CAAQ,SACjC,GAAA,eAAA,CAAgB,QAAQ,GAAG,CAAA,GAC3B,iBAAkB,CAAA,OAAA,CAAQ,GAAG,CAAA,CAAA,CAAA;AAEjC,EAAA,IAAI,CAAC,aAAe,EAAA;AAClB,IAAM,MAAA,IAAI,WAAW,+CAA+C,CAAA,CAAA;AAAA,GACtE;AAEA,EAAA,MAAM,YAAY,aAAe,EAAA,CAAC,MAAQ,EAAA,SAAS,GAAG,SAAS,CAAA,CAAA;AAC/D,EAAA,OAAA;AA8oBF,CAAA,CAAA;AAEO,MAAM,QAAkC,GAAA;AAAA,EAC7C,GAAA,EAAK,QAAQ,GAAI,EAAA;AAAA,EACjB,YAAc,EAAA,KAAA;AAAA,EACd,MAAQ,EAAA,KAAA;AAAA,EACR,IAAM,EAAA,KAAA;AAAA,EACN,MAAQ,EAAA,4CAAA;AAAA,EACR,gBAAkB,EAAA,GAAA;AAAA,EAClB,SAAW,EAAA,cAAA;AAAA,EACX,aAAe,EAAA,mBAAA;AAAA,EACf,aAAe,EAAA,KAAA;AAAA,EACf,uBAAyB,EAAA,OAAA;AAAA,EACzB,0BAA4B,EAAA,KAAA;AAAA,EAC5B,SAAW,EAAA,QAAA;AAAA,EACX,OAAS,EAAA,KAAA;AACX,CAAA,CAAA;AAEe,QACZ,OAAQ,CAAA,SAAS,CACjB,CAAA,KAAA,CAAM,gDAAgD,CACtD,CAAA,SAAA;AAAA,EACC,IAAI,MAAA,CAAO,iBAAmB,EAAA,mCAAmC,CAAE,CAAA,OAAA;AAAA,IACjE,QAAS,CAAA,YAAA;AAAA,GACX;AACF,CACC,CAAA,SAAA,CAAU,IAAI,MAAA,CAAO,OAAS,EAAA,mBAAmB,CAAE,CAAA,OAAA,CAAQ,OAAQ,CAAA,GAAA,EAAK,CAAC,CACzE,CAAA,SAAA;AAAA,EACC,IAAI,MAAA;AAAA,IACF,WAAA;AAAA,IACA,oEAAA;AAAA,GACF,CAAE,OAAQ,CAAA,QAAA,CAAS,MAAM,CAAA;AAC3B,CACC,CAAA,SAAA,CAAU,IAAI,MAAO,CAAA,cAAc,EAAE,OAAQ,CAAA,QAAA,CAAS,OAAO,CAAC,CAC9D,CAAA,SAAA;AAAA,EACC,IAAI,MAAA,CAAO,gBAAkB,EAAA,0BAA0B,EAAE,OAAQ,CAAA;AAAA,IAC/D,OAAA;AAAA,IACA,OAAA;AAAA,IACA,OAAA;AAAA,GACD,CAAA;AACH,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA;AAAA,IACF,4BAAA;AAAA,IACA,6CAAA;AAAA,GACF;AACF,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA;AAAA,IACF,uBAAA;AAAA,IACA,mGAAA;AAAA,GACF,CAAE,QAAQ,4CAA4C,CAAA;AACxD,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA,CAAO,+BAAiC,EAAA,oBAAoB,CAAE,CAAA,OAAA;AAAA,IAChE,QAAS,CAAA,gBAAA;AAAA,GACX;AACF,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA;AAAA,IACF,oBAAA;AAAA,IACA,0CAAA;AAAA,GACF,CAAE,OAAQ,CAAA,QAAA,CAAS,SAAS,CAAA;AAC9B,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA;AAAA,IACF,+BAAA;AAAA,IACA,4JAAA;AAAA,GACF,CAAE,OAAQ,CAAA,QAAA,CAAS,aAAa,CAAA;AAClC,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA,CAAO,yBAA2B,EAAA,kBAAkB,EAAE,OAAQ,CAAA;AAAA,IAChE,QAAA;AAAA,GACD,CAAA;AACH,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA;AAAA,IACF,qCAAA;AAAA,IACA,0DAAA;AAAA,GACF,CACG,OAAQ,CAAA,CAAC,OAAS,EAAA,OAAA,EAAS,OAAO,CAAC,CAAA,CACnC,OAAQ,CAAA,QAAA,CAAS,uBAAuB,CAAA;AAC7C,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA;AAAA,IACF,iCAAA;AAAA,IACA,oHAAA;AAAA,GACF,CAAE,OAAQ,CAAA,QAAA,CAAS,0BAA0B,CAAA;AAC/C,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA;AAAA,IACF,4BAAA;AAAA,IACA,wCAAA;AAAA,GACF,CAAE,OAAQ,CAAA,QAAA,CAAS,SAAS,CAAA;AAC9B,CACC,CAAA,SAAA;AAAA,EACC,IAAI,MAAA;AAAA,IACF,yBAAA;AAAA,IACA,oEAAA;AAAA,GACF;AACF,CAAA,CACC,MAAO,CAAA,CAAC,OAAY,KAAA,oBAAA,CAAqB,OAAO,CAAC,CAAA;;AC52BpD,MAAM,MAAM,IAAK,CAAA,KAAA;AAAA;AAAA,EAEfC,IAAA,CAAG,aAAa,IAAI,GAAA,CAAI,mBAAmB,MAAY,CAAA,IAAA,CAAA,GAAG,GAAG,MAAM,CAAA;AACrE,CAAA,CAAA;AAEA,OAAQ,CAAA,IAAA,CAAK,GAAI,CAAA,IAAI,CAAE,CAAA,WAAA,CAAY,IAAI,WAAW,CAAA,CAAE,OAAQ,CAAA,GAAA,CAAI,OAAO,CAAA,CAAA;AACvE,OAAA,CAAQ,KAAM,EAAA"}